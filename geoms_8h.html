<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>xmsinterp: /home/travis/build/Aquaveo/xmsinterp/xmsinterp/geometry/geoms.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">xmsinterp
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('geoms_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">geoms.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Functions dealing with geometry.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;vector&gt;</code><br/>
<code>#include &lt;<a class="elRef" doxygen="/home/travis/build/Aquaveo/xmsinterp/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore//" href="https://aquaveo.github.io/xmscore/pt_8h.html">xmscore/points/pt.h</a>&gt;</code><br/>
<code>#include &lt;<a class="elRef" doxygen="/home/travis/build/Aquaveo/xmsinterp/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore//" href="https://aquaveo.github.io/xmscore/vector_8h.html">xmscore/stl/vector.h</a>&gt;</code><br/>
</div>
<p><a href="geoms_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a0682e25caba7c1d65216a5680cc0217b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>Turn_enum</b> { <b>xms::TURN_LEFT</b>, 
<b>xms::TURN_RIGHT</b>, 
<b>xms::TURN_COLINEAR_180</b>, 
<b>xms::TURN_COLINEAR_0</b>
 }</td></tr>
<tr class="memdesc:a0682e25caba7c1d65216a5680cc0217b"><td class="mdescLeft">&#160;</td><td class="mdescRight">direction of turn between 3 points <br/></td></tr>
<tr class="separator:a0682e25caba7c1d65216a5680cc0217b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f7d814569daefeabe9f5e3b5fbd213"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>PtInOutOrOn_enum</b> { <b>xms::PT_ERROR</b> = -1, 
<b>xms::PT_IN</b>, 
<b>xms::PT_OUT</b>, 
<b>xms::PT_ON</b>
 }</td></tr>
<tr class="memdesc:a89f7d814569daefeabe9f5e3b5fbd213"><td class="mdescLeft">&#160;</td><td class="mdescRight">point in, out, or on <br/></td></tr>
<tr class="separator:a89f7d814569daefeabe9f5e3b5fbd213"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1460ad596726029e888ef3a0c67cb3ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmPointInOrOnBox2d</b> (const Pt3d &amp;a_bMin, const Pt3d &amp;a_bMax, const Pt3d &amp;a_pt)</td></tr>
<tr class="memdesc:a1460ad596726029e888ef3a0c67cb3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds if a point is in or on a box in 2d  <a href="#a1460ad596726029e888ef3a0c67cb3ec">More...</a><br/></td></tr>
<tr class="separator:a1460ad596726029e888ef3a0c67cb3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8640978d427b51b4ba6c217bb47b12"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmBoxesOverlap2d</b> (const Pt3d &amp;a_b1Min, const Pt3d &amp;a_b1Max, const Pt3d &amp;a_b2Min, const Pt3d &amp;a_b2Max)</td></tr>
<tr class="memdesc:a0a8640978d427b51b4ba6c217bb47b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds if 2 boxes overlap in 2d  <a href="#a0a8640978d427b51b4ba6c217bb47b12">More...</a><br/></td></tr>
<tr class="separator:a0a8640978d427b51b4ba6c217bb47b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815c09c53387db67255d3dce98695778"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmCalculateNormalizedPlaneCoefficients</b> (const Pt3d &amp;p1, const Pt3d &amp;p2, const Pt3d &amp;p3, double *a, double *b, double *c, double *d)</td></tr>
<tr class="memdesc:a815c09c53387db67255d3dce98695778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the plane coefficients for a triangle. Given point references calculate coefficents for plane (ax+by+cz+d=0).  <a href="#a815c09c53387db67255d3dce98695778">More...</a><br/></td></tr>
<tr class="separator:a815c09c53387db67255d3dce98695778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18b77815c5b85e99429ee9240768473"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmCalculateNormalizedPlaneCoefficients</b> (const Pt3d *p1, const Pt3d *p2, const Pt3d *p3, double *a, double *b, double *c, double *d)</td></tr>
<tr class="memdesc:ad18b77815c5b85e99429ee9240768473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the plane coefficients for a triangle. Given point pointers calculate coefficents for plane (ax+by+cz+d=0).  <a href="#ad18b77815c5b85e99429ee9240768473">More...</a><br/></td></tr>
<tr class="separator:ad18b77815c5b85e99429ee9240768473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca28f3227dce2e445d25080fbecbc2c6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmMiddleZ</b> (const VecPt3d &amp;a_points)</td></tr>
<tr class="memdesc:aca28f3227dce2e445d25080fbecbc2c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the z value halfway between the max and min z. Different from the average z (where many points can skew the average).  <a href="#aca28f3227dce2e445d25080fbecbc2c6">More...</a><br/></td></tr>
<tr class="separator:aca28f3227dce2e445d25080fbecbc2c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7879f66ffa765c6ee005573218a4cd"><td class="memItemLeft" align="right" valign="top">PtInOutOrOn_enum&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmPtInCircumcircle</b> (const Pt3d &amp;pt, Pt3d circumcirclePts[3])</td></tr>
<tr class="memdesc:ade7879f66ffa765c6ee005573218a4cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a given point inside a circumcircle defined by three points?  <a href="#ade7879f66ffa765c6ee005573218a4cd">More...</a><br/></td></tr>
<tr class="separator:ade7879f66ffa765c6ee005573218a4cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc383f1bd2f48276705d624db7144c8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmXyDistanceSquared</b> (const Pt3d &amp;pt1, const Pt3d &amp;pt2)</td></tr>
<tr class="memdesc:abfc383f1bd2f48276705d624db7144c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate XY distance between two 3D points.  <a href="#abfc383f1bd2f48276705d624db7144c8">More...</a><br/></td></tr>
<tr class="separator:abfc383f1bd2f48276705d624db7144c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72205354f6d55c7907f6badfbc2e08b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmCircumcircleWithTol</b> (const Pt3d *pt1, const Pt3d *pt2, const Pt3d *pt3, double *xc, double *yc, double *r2, double tol)</td></tr>
<tr class="memdesc:a72205354f6d55c7907f6badfbc2e08b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes center &amp; radius squared for circumcircle of triangle made by the three points.  <a href="#a72205354f6d55c7907f6badfbc2e08b0">More...</a><br/></td></tr>
<tr class="separator:a72205354f6d55c7907f6badfbc2e08b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad512367ef48bf109240552ff3c30cc7a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmCartToBary</b> (const Pt3d *cart, const Pt3d *orig, double coef[6], int dir, Pt3d *bary)</td></tr>
<tr class="memdesc:ad512367ef48bf109240552ff3c30cc7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Barycentric coords for point. Use gmBaryPrepare to get the coefficients and direction.  <a href="#ad512367ef48bf109240552ff3c30cc7a">More...</a><br/></td></tr>
<tr class="separator:ad512367ef48bf109240552ff3c30cc7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065cd6d71205487312c1e03496f5ca08"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmBaryPrepare</b> (const Pt3d *p1, const Pt3d *p2, const Pt3d *p3, const Pt3d *norm, Pt3d *orig, double coef[6], int *dir, bool flag)</td></tr>
<tr class="memdesc:a065cd6d71205487312c1e03496f5ca08"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a tri - compute dir &amp; coefs to compute Barycentric coords.  <a href="#a065cd6d71205487312c1e03496f5ca08">More...</a><br/></td></tr>
<tr class="separator:a065cd6d71205487312c1e03496f5ca08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546070340fe9bdf56641efa002a27ac9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmColinearWithTol</b> (const Pt3d &amp;p1, const Pt3d &amp;p2, const Pt3d &amp;p3, const double tol)</td></tr>
<tr class="memdesc:a546070340fe9bdf56641efa002a27ac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if (the three vertices are gmColinear. Result should be insensitive to the order of the vertices.  <a href="#a546070340fe9bdf56641efa002a27ac9">More...</a><br/></td></tr>
<tr class="separator:a546070340fe9bdf56641efa002a27ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96bb6c54af013c284ac2c3657626c67"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmIntersectLineSegmentsWithTol</b> (const Pt3d &amp;one1, const Pt3d &amp;one2, const Pt3d &amp;two1, const Pt3d &amp;two2, double *xi, double *yi, double *zi1, double *zi2, double tol)</td></tr>
<tr class="memdesc:ac96bb6c54af013c284ac2c3657626c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersects the plan projection of two line segments.  <a href="#ac96bb6c54af013c284ac2c3657626c67">More...</a><br/></td></tr>
<tr class="separator:ac96bb6c54af013c284ac2c3657626c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098ef608f7092e087f9a456709714fea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmCounterClockwiseTri</b> (const Pt3d &amp;vtx0, const Pt3d &amp;vtx1, const Pt3d &amp;vtx2)</td></tr>
<tr class="memdesc:a098ef608f7092e087f9a456709714fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the triangle is wrapped counter clockwise.  <a href="#a098ef608f7092e087f9a456709714fea">More...</a><br/></td></tr>
<tr class="separator:a098ef608f7092e087f9a456709714fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f4c8c6bc396759e5d8953d85530b46"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmCross2D</b> (const double &amp;dx1, const double &amp;dy1, const double &amp;dx2, const double &amp;dy2)</td></tr>
<tr class="memdesc:a06f4c8c6bc396759e5d8953d85530b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the cross product of two 2-d vectors.  <a href="#a06f4c8c6bc396759e5d8953d85530b46">More...</a><br/></td></tr>
<tr class="separator:a06f4c8c6bc396759e5d8953d85530b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf14a948fef6fc782b4e7210652ad35"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmAngleBetween2DVectors</b> (double dxp, double dyp, double dxn, double dyn)</td></tr>
<tr class="memdesc:aacf14a948fef6fc782b4e7210652ad35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the angle (0-2PI) in radians between the edges p and n based on a ccw rotation from p to n.  <a href="#aacf14a948fef6fc782b4e7210652ad35">More...</a><br/></td></tr>
<tr class="separator:aacf14a948fef6fc782b4e7210652ad35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ee7df906ccbedcb3b364d1a5571f60"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmAngleBetween2DVectors</b> (double dxp, double dyp, double dxn, double dyn, double a_magn, double a_magp)</td></tr>
<tr class="memdesc:ae9ee7df906ccbedcb3b364d1a5571f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the angle (0-2PI) in radians between the edges p and n based on a ccw rotation from p to n.  <a href="#ae9ee7df906ccbedcb3b364d1a5571f60">More...</a><br/></td></tr>
<tr class="separator:ae9ee7df906ccbedcb3b364d1a5571f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d19a71ee810d5a16ea601d9ca7dda8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmAngleBetweenEdges</b> (const Pt3d &amp;p1, const Pt3d &amp;p2, const Pt3d &amp;p3)</td></tr>
<tr class="memdesc:ad5d19a71ee810d5a16ea601d9ca7dda8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ccw angle (0-2pi) between p2-p1 and p2-p3.  <a href="#ad5d19a71ee810d5a16ea601d9ca7dda8">More...</a><br/></td></tr>
<tr class="separator:ad5d19a71ee810d5a16ea601d9ca7dda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b051e3a396a16ae9a9a24b4350164c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmAngleBetweenEdges</b> (const Pt2d &amp;p1, const Pt2d &amp;p2, const Pt2d &amp;p3)</td></tr>
<tr class="memdesc:a93b051e3a396a16ae9a9a24b4350164c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ccw angle (0-2pi) between p2-p1 and p2-p3.  <a href="#a93b051e3a396a16ae9a9a24b4350164c">More...</a><br/></td></tr>
<tr class="separator:a93b051e3a396a16ae9a9a24b4350164c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7bbeb7ef537825868d7e70021d918c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmComputeDeviationInDirection</b> (const Pt3d &amp;a_p0, const Pt3d &amp;a_p1, const Pt3d &amp;a_p2)</td></tr>
<tr class="memdesc:a7d7bbeb7ef537825868d7e70021d918c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the deviation in direction from one seg to next seg 1 is from a_p0 to a_p1 seg 2 is from a_p1 to a_p2.  <a href="#a7d7bbeb7ef537825868d7e70021d918c">More...</a><br/></td></tr>
<tr class="separator:a7d7bbeb7ef537825868d7e70021d918c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169625a9f18e45ac2b67fac67c5db715"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmOnLineAndBetweenEndpointsWithTol</b> (const Pt3d &amp;a_pt1, const Pt3d &amp;a_pt2, const double a_x, const double a_y, double a_tol)</td></tr>
<tr class="memdesc:a169625a9f18e45ac2b67fac67c5db715"><td class="mdescLeft">&#160;</td><td class="mdescRight">determines if (x,y) is on the line passing through p1 &amp; p2 and between p1 &amp; p2.  <a href="#a169625a9f18e45ac2b67fac67c5db715">More...</a><br/></td></tr>
<tr class="separator:a169625a9f18e45ac2b67fac67c5db715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45139efe30e550bbc370542f8e69a76f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmOnLineWithTol</b> (const Pt3d &amp;p1, const Pt3d &amp;p2, const double x, const double y, const double tol)</td></tr>
<tr class="memdesc:a45139efe30e550bbc370542f8e69a76f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a point (x,y) is on the line defined by p1 and p2. Assumes p1 and p2 aren't the same.  <a href="#a45139efe30e550bbc370542f8e69a76f">More...</a><br/></td></tr>
<tr class="separator:a45139efe30e550bbc370542f8e69a76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4416101125e2de1d4301a09f34cc4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmAddToExtents</b> (const Pt3d &amp;a_pt, Pt3d &amp;a_min, Pt3d &amp;a_max)</td></tr>
<tr class="memdesc:a7b4416101125e2de1d4301a09f34cc4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares <em>a_pt</em> to <em>a_min</em> and <em>a_max</em>. If <em>a_pt</em> is less than <em>a_min</em> or greater than <em>a_max</em>, <em>a_min</em> and <em>a_max</em> are updated.  <a href="#a7b4416101125e2de1d4301a09f34cc4a">More...</a><br/></td></tr>
<tr class="separator:a7b4416101125e2de1d4301a09f34cc4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d89b95b5652b82ece1415a73f6d102b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmAddToExtents</b> (const Pt3d &amp;a_pt, Pt2d &amp;a_min, Pt2d &amp;a_max)</td></tr>
<tr class="separator:a3d89b95b5652b82ece1415a73f6d102b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3d405fd7c3488c385b0caa932f9cba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmAddToExtents</b> (const Pt2d &amp;a_pt, Pt3d &amp;a_min, Pt3d &amp;a_max)</td></tr>
<tr class="separator:a6c3d405fd7c3488c385b0caa932f9cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d8975fe80c8ec9c9b424cf26e5e755"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmXyDistance</b> (double x1, double y1, double x2, double y2)</td></tr>
<tr class="memdesc:a67d8975fe80c8ec9c9b424cf26e5e755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 2d distance between 2 points.  <a href="#a67d8975fe80c8ec9c9b424cf26e5e755">More...</a><br/></td></tr>
<tr class="separator:a67d8975fe80c8ec9c9b424cf26e5e755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a89d9544f63308d7a3c31e99c8281a9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmXyDistance</b> (const Pt3d &amp;pt1, const Pt3d &amp;pt2)</td></tr>
<tr class="separator:a9a89d9544f63308d7a3c31e99c8281a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4700adae0c06deec6e84e436c86f276b"><td class="memItemLeft" align="right" valign="top">Turn_enum&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmTurn</b> (const Pt3d &amp;a_v1, const Pt3d &amp;a_v2, const Pt3d &amp;a_v3, double a_angtol)</td></tr>
<tr class="memdesc:a4700adae0c06deec6e84e436c86f276b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if angle a_v1, a_v2, a_v3 is a left turn, a right turn, colinear 180 degrees, or colinear 0 degrees.  <a href="#a4700adae0c06deec6e84e436c86f276b">More...</a><br/></td></tr>
<tr class="separator:a4700adae0c06deec6e84e436c86f276b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac462cb8b1fc78478a3f6cad9073a37e9"><td class="memItemLeft" align="right" valign="top">Pt3d&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmComputeCentroid</b> (const VecPt3d &amp;a_points)</td></tr>
<tr class="memdesc:ac462cb8b1fc78478a3f6cad9073a37e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the centroid of points (but not of a polygon). Shouldn't pass an empty vector (no checks are performed).  <a href="#ac462cb8b1fc78478a3f6cad9073a37e9">More...</a><br/></td></tr>
<tr class="separator:ac462cb8b1fc78478a3f6cad9073a37e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a728b2937701be72dc73f3f66ac2e7fbf"><td class="memItemLeft" align="right" valign="top">Pt3d&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmComputePolygonCentroid</b> (const VecPt3d &amp;pts)</td></tr>
<tr class="memdesc:a728b2937701be72dc73f3f66ac2e7fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the plan view centroid of a non-self-intersecting polygon.  <a href="#a728b2937701be72dc73f3f66ac2e7fbf">More...</a><br/></td></tr>
<tr class="separator:a728b2937701be72dc73f3f66ac2e7fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc56691197d92d60abcb0e77e48df4ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmLinesIntersect</b> (const Pt3d &amp;one1, const Pt3d &amp;one2, const Pt3d &amp;two1, const Pt3d &amp;two2)</td></tr>
<tr class="memdesc:adc56691197d92d60abcb0e77e48df4ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">intersects the plan projection of two line segments (bad func name) segment 1 = one1,one2 = one1 + lambda(one2 - one1) segment 2 = two1,two2 = two1 + mu (two2 - two1)  <a href="#adc56691197d92d60abcb0e77e48df4ea">More...</a><br/></td></tr>
<tr class="separator:adc56691197d92d60abcb0e77e48df4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457f87dda88f474bebe491ec094b693f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmPointInPolygon2D</b> (const Pt3d *a_verts, size_t a_num, double a_x, double a_y)</td></tr>
<tr class="separator:a457f87dda88f474bebe491ec094b693f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32ddc6f5892464bfe6d596c1922f7f5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmPointInPolygon2D</b> (const Pt3d *a_verts, size_t a_num, Pt3d a_pt)</td></tr>
<tr class="separator:aa32ddc6f5892464bfe6d596c1922f7f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959d71253e45c5f67e1bf202a5a122fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmPointInPolygon2D</b> (const Pt2i *a_verts, size_t a_num, Pt2d a_pt)</td></tr>
<tr class="separator:a959d71253e45c5f67e1bf202a5a122fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b879e6c80208a8780496137ac51c3c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmPointInPolygon2D</b> (const Pt2i *a_verts, size_t a_num, Pt2i a_pt)</td></tr>
<tr class="separator:a3b879e6c80208a8780496137ac51c3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac4a8fdb18373864527f2fad0bb8c433"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmPointInPolygon2D</b> (const Pt2i *a_verts, size_t a_num, Pt3d a_pt)</td></tr>
<tr class="separator:aac4a8fdb18373864527f2fad0bb8c433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad56bb08be2f1969cd7912f59d49d9e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmPointInPolygon2D</b> (const VecPt3d &amp;a_verts, const Pt3d &amp;a_pt)</td></tr>
<tr class="separator:aad56bb08be2f1969cd7912f59d49d9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43bab17fe8d6f6b67de11a49e5127424"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a43bab17fe8d6f6b67de11a49e5127424"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>xms::gmPointInPolygon2D</b> (const T *a_verts, const size_t a_num, const double a_x, const double a_y, const double a_tol)</td></tr>
<tr class="memdesc:a43bab17fe8d6f6b67de11a49e5127424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether (a_x, a_y) is inside=1, on=0, or outside=-1 the polygon defined by the given vertices.  <a href="#a43bab17fe8d6f6b67de11a49e5127424">More...</a><br/></td></tr>
<tr class="separator:a43bab17fe8d6f6b67de11a49e5127424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03126d64edc4ecb587a357fbfa5fb08c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmComputeXyTol</b> (const Pt3d &amp;a_mn, const Pt3d &amp;a_mx)</td></tr>
<tr class="memdesc:a03126d64edc4ecb587a357fbfa5fb08c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given extents (min, max), compute a tolerance for the xy plane to be used with geometric functions.  <a href="#a03126d64edc4ecb587a357fbfa5fb08c">More...</a><br/></td></tr>
<tr class="separator:a03126d64edc4ecb587a357fbfa5fb08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a33258adddbd27ad36954f6ccdcdef7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmXyTol</b> (bool a_set, double a_value)</td></tr>
<tr class="memdesc:a7a33258adddbd27ad36954f6ccdcdef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get or set (set first time) global xy tolerance for float operations.  <a href="#a7a33258adddbd27ad36954f6ccdcdef7">More...</a><br/></td></tr>
<tr class="separator:a7a33258adddbd27ad36954f6ccdcdef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e7dba5dafe577d6345afe25580777a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmZTol</b> (bool a_set, double a_value)</td></tr>
<tr class="memdesc:af0e7dba5dafe577d6345afe25580777a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get or set (set first time) global z tolerance for float operations.  <a href="#af0e7dba5dafe577d6345afe25580777a">More...</a><br/></td></tr>
<tr class="separator:af0e7dba5dafe577d6345afe25580777a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac504f8315cad401c34447f06c5b6b07d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmEqualPointsXY</b> (double x1, double y1, double x2, double y2)</td></tr>
<tr class="separator:ac504f8315cad401c34447f06c5b6b07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a226e666728d9fde914f18db63a4714"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmEqualPointsXY</b> (double x1, double y1, double x2, double y2, double tolerance)</td></tr>
<tr class="memdesc:a9a226e666728d9fde914f18db63a4714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the points are equal to within gmXyTol().  <a href="#a9a226e666728d9fde914f18db63a4714">More...</a><br/></td></tr>
<tr class="separator:a9a226e666728d9fde914f18db63a4714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a878ec06b0e9bbd3afccd2bf70ec54621"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmEqualPointsXY</b> (const Pt2i &amp;point1, const Pt2i &amp;point2)</td></tr>
<tr class="separator:a878ec06b0e9bbd3afccd2bf70ec54621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a427db5d209d5d8d22ec417417de4d702"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmEqualPointsXY</b> (const Pt2d &amp;a_pt1, const Pt2d &amp;a_pt2, double tol)</td></tr>
<tr class="separator:a427db5d209d5d8d22ec417417de4d702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6724be333a3994b7cb0bbe1ec832f244"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmEqualPointsXY</b> (const Pt3d &amp;a_pt1, const Pt3d &amp;a_pt2, double tol)</td></tr>
<tr class="separator:a6724be333a3994b7cb0bbe1ec832f244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4ba75c670a283360048a5365558916"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmEqualPointsXYZ</b> (double x1, double y1, double z1, double x2, double y2, double z2)</td></tr>
<tr class="separator:a6e4ba75c670a283360048a5365558916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3a08ccd01c4230e7498d793a9d90cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmEqualPointsXYZ</b> (double x1, double y1, double z1, double x2, double y2, double z2, double tolerance)</td></tr>
<tr class="memdesc:a8c3a08ccd01c4230e7498d793a9d90cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the points are equal to within tolerance.  <a href="#a8c3a08ccd01c4230e7498d793a9d90cd">More...</a><br/></td></tr>
<tr class="separator:a8c3a08ccd01c4230e7498d793a9d90cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a326b40120fd0517c654d9a94a963e83e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmEqualPointsXYZ</b> (const Pt3d &amp;pt1, const Pt3d &amp;pt2, double tol)</td></tr>
<tr class="separator:a326b40120fd0517c654d9a94a963e83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b2cb41a4510b0ba885d4a4691781506"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmPointInTriangleWithTol</b> (const Pt3d *p1, const Pt3d *p2, const Pt3d *p3, double x, double y, double tol)</td></tr>
<tr class="memdesc:a5b2cb41a4510b0ba885d4a4691781506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if (x,y) is in the tri formed by p1, p2, p3.  <a href="#a5b2cb41a4510b0ba885d4a4691781506">More...</a><br/></td></tr>
<tr class="separator:a5b2cb41a4510b0ba885d4a4691781506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f9850dc05d9598dcd1e4d06d7a64a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmInsideOrOnLineWithTol</b> (const Pt3d *p1, const Pt3d *p2, const Pt3d *inpoint, const double x, const double y, const double tol, double *dist)</td></tr>
<tr class="memdesc:a33f9850dc05d9598dcd1e4d06d7a64a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the (x,y) is on the line segment (p1,p2) or on the same side of the line as "inpoint". ASSERTs in debug if "inpoint" is on the line (within tol).  <a href="#a33f9850dc05d9598dcd1e4d06d7a64a2">More...</a><br/></td></tr>
<tr class="separator:a33f9850dc05d9598dcd1e4d06d7a64a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299579fe39539f353e245d1c41c8eb0f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmPolygonArea</b> (const Pt3d *pts, size_t npoints)</td></tr>
<tr class="memdesc:a299579fe39539f353e245d1c41c8eb0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute 2d planview projection of area of polygon.  <a href="#a299579fe39539f353e245d1c41c8eb0f">More...</a><br/></td></tr>
<tr class="separator:a299579fe39539f353e245d1c41c8eb0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7877ffa4620ae49b12d0b49de2289135"><td class="memItemLeft" align="right" valign="top">VecPt3d&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmArrayToVecPt3d</b> (double *a_array, int a_size)</td></tr>
<tr class="memdesc:a7877ffa4620ae49b12d0b49de2289135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful in testing to create a VecPt3d from a C array of xy pairs.  <a href="#a7877ffa4620ae49b12d0b49de2289135">More...</a><br/></td></tr>
<tr class="separator:a7877ffa4620ae49b12d0b49de2289135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0fecb3c9d9aa77f4ff42ec6a608f26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmEnvelopeOfPts</b> (const VecPt3d &amp;a_pts, Pt3d &amp;a_min, Pt3d &amp;a_max)</td></tr>
<tr class="memdesc:aeb0fecb3c9d9aa77f4ff42ec6a608f26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the envelope of a vector of points.  <a href="#aeb0fecb3c9d9aa77f4ff42ec6a608f26">More...</a><br/></td></tr>
<tr class="separator:aeb0fecb3c9d9aa77f4ff42ec6a608f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3222874630da8f1f8537f1a6135846f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmOrderPointsCounterclockwise</b> (const VecPt3d &amp;a_pts, VecInt &amp;a_ccwOrder, int a_startindex)</td></tr>
<tr class="memdesc:ac3222874630da8f1f8537f1a6135846f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orders array of points counter clockwise. Given non-empty array of points. array of point indices ordered counter clockwise based on the angle from the centroid where angle starts at point at startindex.  <a href="#ac3222874630da8f1f8537f1a6135846f">More...</a><br/></td></tr>
<tr class="separator:ac3222874630da8f1f8537f1a6135846f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed9ee1170ee7004d626347f8886e4943"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmOrderPointsCounterclockwise</b> (VecPt3d &amp;a_pts)</td></tr>
<tr class="memdesc:aed9ee1170ee7004d626347f8886e4943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload to gmOrderPointsCounterclockwise.  <a href="#aed9ee1170ee7004d626347f8886e4943">More...</a><br/></td></tr>
<tr class="separator:aed9ee1170ee7004d626347f8886e4943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89c693cc48610a4a7dcf89f22d55118"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmFindClosestPtOnSegment</b> (const Pt3d &amp;a_pt1, const Pt3d &amp;a_pt2, const Pt3d &amp;a_pt, Pt3d &amp;a_newpt, const double a_tol)</td></tr>
<tr class="memdesc:ad89c693cc48610a4a7dcf89f22d55118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the closest point to another point on a segment.  <a href="#ad89c693cc48610a4a7dcf89f22d55118">More...</a><br/></td></tr>
<tr class="separator:ad89c693cc48610a4a7dcf89f22d55118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9e75d979ef1bc5c0c217115eb34a04"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmPtDistanceAlongSegment</b> (const Pt3d &amp;a_pt1, const Pt3d &amp;a_pt2, const Pt3d &amp;a_pt, const double a_tol)</td></tr>
<tr class="memdesc:a9f9e75d979ef1bc5c0c217115eb34a04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the distance along a segment for the location closest to a_pt.  <a href="#a9f9e75d979ef1bc5c0c217115eb34a04">More...</a><br/></td></tr>
<tr class="separator:a9f9e75d979ef1bc5c0c217115eb34a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78a4612aa080741e2ce7aa301aab615"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmInsideOfLineWithTol</b> (const Pt3d &amp;a_vertex1, const Pt3d &amp;a_vertex2, const Pt3d &amp;a_oppositevertex, const double a_x, const double a_y, const double a_tol)</td></tr>
<tr class="memdesc:aa78a4612aa080741e2ce7aa301aab615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns TRUE if the Point on the same side of the line (defined by vertex1 and vertex2) as oppositevertex.  <a href="#aa78a4612aa080741e2ce7aa301aab615">More...</a><br/></td></tr>
<tr class="separator:aa78a4612aa080741e2ce7aa301aab615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a42e7eea0d9ce1dfebc230e50ad166"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmExtents2D</b> (const VecPt3d &amp;a_points, Pt2d &amp;a_min, Pt2d &amp;a_max)</td></tr>
<tr class="memdesc:a38a42e7eea0d9ce1dfebc230e50ad166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the 2D extents of a vector of points.  <a href="#a38a42e7eea0d9ce1dfebc230e50ad166">More...</a><br/></td></tr>
<tr class="separator:a38a42e7eea0d9ce1dfebc230e50ad166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21eba0393f3071a3af665e8cfedb7bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmExtents2D</b> (const VecPt3d &amp;a_points, Pt3d &amp;a_min, Pt3d &amp;a_max)</td></tr>
<tr class="separator:ac21eba0393f3071a3af665e8cfedb7bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c2eb4bc4667e6479497b0b529562c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmExtents3D</b> (const VecPt3d &amp;a_points, Pt3d &amp;a_min, Pt3d &amp;a_max)</td></tr>
<tr class="memdesc:ac4c2eb4bc4667e6479497b0b529562c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the 3D extents of a vector of points.  <a href="#ac4c2eb4bc4667e6479497b0b529562c8">More...</a><br/></td></tr>
<tr class="separator:ac4c2eb4bc4667e6479497b0b529562c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8397c11d92c81098edabbc41ab06bffa"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmPerpendicularAngle</b> (const Pt3d &amp;a_pt1, const Pt3d &amp;a_pt2)</td></tr>
<tr class="memdesc:a8397c11d92c81098edabbc41ab06bffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the angle in radians perpendicular to the two points.  <a href="#a8397c11d92c81098edabbc41ab06bffa">More...</a><br/></td></tr>
<tr class="separator:a8397c11d92c81098edabbc41ab06bffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc887b28d4ef88ce8c14aab5482765a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmBisectingAngle</b> (const Pt3d &amp;a_p1, const Pt3d &amp;a_p2, const Pt3d &amp;a_p3)</td></tr>
<tr class="memdesc:afbc887b28d4ef88ce8c14aab5482765a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the angle (0-2pi) which bisects the edges p2-p1 and p2-p3 based on a ccw rotation from edge 1 to edge 2.  <a href="#afbc887b28d4ef88ce8c14aab5482765a">More...</a><br/></td></tr>
<tr class="separator:afbc887b28d4ef88ce8c14aab5482765a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214f89ef03c8dd4f0ca2e4418fc1757d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmComponentMagnitudes</b> (double *a_x, double *a_y, double *a_mag, double *a_dir, bool a_tomagdir)</td></tr>
<tr class="memdesc:a214f89ef03c8dd4f0ca2e4418fc1757d"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts the magnitude and angle to xy components or vice versa  <a href="#a214f89ef03c8dd4f0ca2e4418fc1757d">More...</a><br/></td></tr>
<tr class="separator:a214f89ef03c8dd4f0ca2e4418fc1757d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15d7a7439937df12789f169f594c3df"><td class="memItemLeft" align="right" valign="top">Pt3d&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmCreateVector</b> (const Pt3d &amp;a_p1, const Pt3d &amp;a_p2)</td></tr>
<tr class="memdesc:ae15d7a7439937df12789f169f594c3df"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a vector from a_p1 to a_p2  <a href="#ae15d7a7439937df12789f169f594c3df">More...</a><br/></td></tr>
<tr class="separator:ae15d7a7439937df12789f169f594c3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de1bfdf51c7b4ee1b3c2a3f1ecb96ba"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmConvertAngleToBetween0And360</b> (double a_angle, bool a_InDegrees)</td></tr>
<tr class="memdesc:a3de1bfdf51c7b4ee1b3c2a3f1ecb96ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">given an angle, this function will return the corresponding angle that matches it in the range of 0 deg to 360 deg  <a href="#a3de1bfdf51c7b4ee1b3c2a3f1ecb96ba">More...</a><br/></td></tr>
<tr class="separator:a3de1bfdf51c7b4ee1b3c2a3f1ecb96ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff1edecd418a115ea72edd1fffc115e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmCross3D</b> (const Pt3d &amp;a_vec1, const Pt3d &amp;a_vec2, Pt3d *a_vec3)</td></tr>
<tr class="memdesc:afff1edecd418a115ea72edd1fffc115e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a cross product of Pt3d's.  <a href="#afff1edecd418a115ea72edd1fffc115e">More...</a><br/></td></tr>
<tr class="separator:afff1edecd418a115ea72edd1fffc115e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f5cd9ea7e783cdb00ba6ec4f88a357"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmDot3D</b> (const Pt3d &amp;a_vec1, const Pt3d &amp;a_vec2)</td></tr>
<tr class="memdesc:a02f5cd9ea7e783cdb00ba6ec4f88a357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a dot product of Pt3d's.  <a href="#a02f5cd9ea7e783cdb00ba6ec4f88a357">More...</a><br/></td></tr>
<tr class="separator:a02f5cd9ea7e783cdb00ba6ec4f88a357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82e28a71a8e0794c21d756c2308fd3b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gmIntersectTriangleAndLineSegment</b> (const Pt3d &amp;a_pt1, const Pt3d &amp;a_pt2, const Pt3d &amp;a_t0, const Pt3d &amp;a_t1, const Pt3d &amp;a_t2, Pt3d &amp;a_IntersectPt)</td></tr>
<tr class="memdesc:ab82e28a71a8e0794c21d756c2308fd3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the line (described by a_pt1 and a_pt2) intersects the triangle (a_t0, a_t1, a_t2).  <a href="#ab82e28a71a8e0794c21d756c2308fd3b">More...</a><br/></td></tr>
<tr class="separator:ab82e28a71a8e0794c21d756c2308fd3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9684415f055c6e1f7b779d3a9e84f609"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><b>xms::gm2DDistanceToLineWithTol</b> (const Pt3d *a_pt1, const Pt3d *a_pt2, double a_x, double a_y, double a_tol)</td></tr>
<tr class="memdesc:a9684415f055c6e1f7b779d3a9e84f609"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the xy distance from (a_x,a_y) to line through (a_pt1, a_pt2)  <a href="#a9684415f055c6e1f7b779d3a9e84f609">More...</a><br/></td></tr>
<tr class="separator:a9684415f055c6e1f7b779d3a9e84f609"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Functions dealing with geometry. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>(C) Copyright Aquaveo 2018. Distributed under the xmsng Software License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at <a href="http://www.aquaveo.com/xmsng/LICENSE_1_0.txt">http://www.aquaveo.com/xmsng/LICENSE_1_0.txt</a>) </dd></dl>

<p>Definition in file <a class="el" href="geoms_8h_source.html">geoms.h</a>.</p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d5bd44cca6d9b750fd281691fd2973a5.html">xmsinterp</a></li><li class="navelem"><a class="el" href="dir_11d77a5cb34d2dcd924ab16385f16337.html">geometry</a></li><li class="navelem"><a class="el" href="geoms_8h.html">geoms.h</a></li>
    <li class="footer">Generated on Sun Jul 1 2018 22:11:41 for xmsinterp by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
