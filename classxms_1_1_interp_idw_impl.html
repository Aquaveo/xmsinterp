<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>xmsinterp: xms::InterpIdwImpl Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">xmsinterp
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classxms_1_1_interp_idw_impl.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classxms_1_1_interp_idw_impl-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">xms::InterpIdwImpl Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implementation of <a class="el" href="classxms_1_1_interp_idw.html" title="Class that performs inverse distance weighted interpolation. ">InterpIdw</a> class.  
 <a href="classxms_1_1_interp_idw_impl.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for xms::InterpIdwImpl:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classxms_1_1_interp_idw_impl.png" usemap="#xms::InterpIdwImpl_map" alt=""/>
  <map id="xms::InterpIdwImpl_map" name="xms::InterpIdwImpl_map">
<area href="classxms_1_1_interp_idw.html" title="Class that performs inverse distance weighted interpolation. " alt="xms::InterpIdw" shape="rect" coords="0,56,112,80"/>
<area href="classxms_1_1_interp_base.html" title="Base class for interpolation methods. " alt="xms::InterpBase" shape="rect" coords="0,0,112,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl_1_1_interp_thread.html">InterpThread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threading class to compute idw interpolation in parallel.  <a href="classxms_1_1_interp_idw_impl_1_1_interp_thread.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abe90be24339d7ffd104efc2b29bdcc63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe90be24339d7ffd104efc2b29bdcc63"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#abe90be24339d7ffd104efc2b29bdcc63">InterpIdwImpl</a> ()</td></tr>
<tr class="memdesc:abe90be24339d7ffd104efc2b29bdcc63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="classxms_1_1_interp_idw.html" title="Class that performs inverse distance weighted interpolation. ">InterpIdw</a> class. <br/></td></tr>
<tr class="separator:abe90be24339d7ffd104efc2b29bdcc63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34c7cead7fc8a591985593e3fc0d000"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#af34c7cead7fc8a591985593e3fc0d000">SetPtsTris</a> (<a class="elRef" doxygen="/home/travis/build/Aquaveo/xmsinterp/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore//" href="https://aquaveo.github.io/xmscore/boost__defines_8h.html#a37efc6913312f9271e2ea37f1acbc2dc">BSHP</a>&lt; VecPt3d &gt; a_pts, <a class="elRef" doxygen="/home/travis/build/Aquaveo/xmsinterp/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore//" href="https://aquaveo.github.io/xmscore/boost__defines_8h.html#a37efc6913312f9271e2ea37f1acbc2dc">BSHP</a>&lt; VecInt &gt; a_tris)</td></tr>
<tr class="memdesc:af34c7cead7fc8a591985593e3fc0d000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the points that will be used to do the interpolation.  <a href="#af34c7cead7fc8a591985593e3fc0d000">More...</a><br/></td></tr>
<tr class="separator:af34c7cead7fc8a591985593e3fc0d000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4b1e66423c71e58b71c69132525aa4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#a2d4b1e66423c71e58b71c69132525aa4">SetPts</a> (<a class="elRef" doxygen="/home/travis/build/Aquaveo/xmsinterp/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore//" href="https://aquaveo.github.io/xmscore/boost__defines_8h.html#a37efc6913312f9271e2ea37f1acbc2dc">BSHP</a>&lt; std::vector&lt; Pt3d &gt;&gt; a_pts, bool a_2d)</td></tr>
<tr class="memdesc:a2d4b1e66423c71e58b71c69132525aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the points that will be used to do the interpolation.  <a href="#a2d4b1e66423c71e58b71c69132525aa4">More...</a><br/></td></tr>
<tr class="separator:a2d4b1e66423c71e58b71c69132525aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6241d646bacd9de44bcf1e346e094d"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#a0b6241d646bacd9de44bcf1e346e094d">InterpToPt</a> (const Pt3d &amp;a_pt) override</td></tr>
<tr class="memdesc:a0b6241d646bacd9de44bcf1e346e094d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates to the location specified by a_pt and returns the value.  <a href="#a0b6241d646bacd9de44bcf1e346e094d">More...</a><br/></td></tr>
<tr class="separator:a0b6241d646bacd9de44bcf1e346e094d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf865202659ed8b760a1524b00f7593"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#accf865202659ed8b760a1524b00f7593">InterpToPts</a> (const std::vector&lt; Pt3d &gt; &amp;a_pts, std::vector&lt; float &gt; &amp;a_scalars)</td></tr>
<tr class="memdesc:accf865202659ed8b760a1524b00f7593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates to an array of points and fills in an array of scalars. This method will run in parallel using multiple threads.  <a href="#accf865202659ed8b760a1524b00f7593">More...</a><br/></td></tr>
<tr class="separator:accf865202659ed8b760a1524b00f7593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d04a94ccc0c154d0a393121e24185e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#ae4d04a94ccc0c154d0a393121e24185e">SetPtActivity</a> (DynBitset &amp;a_activity)</td></tr>
<tr class="memdesc:ae4d04a94ccc0c154d0a393121e24185e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the activity on the point being used to interpolate.  <a href="#ae4d04a94ccc0c154d0a393121e24185e">More...</a><br/></td></tr>
<tr class="separator:ae4d04a94ccc0c154d0a393121e24185e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf8de95138f5b5a73411b4d1d77e2bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abdf8de95138f5b5a73411b4d1d77e2bc"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#abdf8de95138f5b5a73411b4d1d77e2bc">SetTriActivity</a> (DynBitset &amp;)</td></tr>
<tr class="memdesc:abdf8de95138f5b5a73411b4d1d77e2bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets triangle activity. Ignored by IDW. <br/></td></tr>
<tr class="separator:abdf8de95138f5b5a73411b4d1d77e2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af674b8955a7ecebacc2d7c4a8cfe7bce"><td class="memItemLeft" align="right" valign="top">virtual <a class="elRef" doxygen="/home/travis/build/Aquaveo/xmsinterp/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore//" href="https://aquaveo.github.io/xmscore/boost__defines_8h.html#a37efc6913312f9271e2ea37f1acbc2dc">BSHP</a>&lt; std::vector&lt; Pt3d &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#af674b8955a7ecebacc2d7c4a8cfe7bce">GetPts</a> ()</td></tr>
<tr class="memdesc:af674b8955a7ecebacc2d7c4a8cfe7bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns shared pointer to points vector.  <a href="#af674b8955a7ecebacc2d7c4a8cfe7bce">More...</a><br/></td></tr>
<tr class="separator:af674b8955a7ecebacc2d7c4a8cfe7bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f49dccc1544e1e04b16358e458a94cb"><td class="memItemLeft" align="right" valign="top">virtual <a class="elRef" doxygen="/home/travis/build/Aquaveo/xmsinterp/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore//" href="https://aquaveo.github.io/xmscore/boost__defines_8h.html#a37efc6913312f9271e2ea37f1acbc2dc">BSHP</a>&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#a2f49dccc1544e1e04b16358e458a94cb">GetTris</a> ()</td></tr>
<tr class="memdesc:a2f49dccc1544e1e04b16358e458a94cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns shared pointer to triangles vector.  <a href="#a2f49dccc1544e1e04b16358e458a94cb">More...</a><br/></td></tr>
<tr class="separator:a2f49dccc1544e1e04b16358e458a94cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3360ed1fa84ea3addbb31580c4cfbb77"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#a3360ed1fa84ea3addbb31580c4cfbb77">SetTrunc</a> (double a_sMax, double a_sMin) override</td></tr>
<tr class="memdesc:a3360ed1fa84ea3addbb31580c4cfbb77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the truncation values for the interpolation and turn on truncation.  <a href="#a3360ed1fa84ea3addbb31580c4cfbb77">More...</a><br/></td></tr>
<tr class="separator:a3360ed1fa84ea3addbb31580c4cfbb77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e7e3a8ff23af9ca36cec3a9deed4f8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#ad8e7e3a8ff23af9ca36cec3a9deed4f8">SetSaveWeights</a> (bool a_) override</td></tr>
<tr class="memdesc:ad8e7e3a8ff23af9ca36cec3a9deed4f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets a flag to save the weights computed by the interpolation  <a href="#ad8e7e3a8ff23af9ca36cec3a9deed4f8">More...</a><br/></td></tr>
<tr class="separator:ad8e7e3a8ff23af9ca36cec3a9deed4f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475b892911b0603b88c01efef172ecd9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#a475b892911b0603b88c01efef172ecd9">InterpWeights</a> (const Pt3d &amp;a_pt, std::vector&lt; int &gt; &amp;a_idx, std::vector&lt; double &gt; &amp;a_wt) const </td></tr>
<tr class="memdesc:a475b892911b0603b88c01efef172ecd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a location and an array of points the weights associated with array of points are calculated.  <a href="#a475b892911b0603b88c01efef172ecd9">More...</a><br/></td></tr>
<tr class="separator:a475b892911b0603b88c01efef172ecd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ea5690b1c3e9de099ce4478e138cca"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#a95ea5690b1c3e9de099ce4478e138cca">SetMultiThreading</a> (bool a_) override</td></tr>
<tr class="memdesc:a95ea5690b1c3e9de099ce4478e138cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets a flag to use (or not) multi-threading when interpolating  <a href="#a95ea5690b1c3e9de099ce4478e138cca">More...</a><br/></td></tr>
<tr class="separator:a95ea5690b1c3e9de099ce4478e138cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca966e59b934c8ccf1301fa8ed1d36b4"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#aca966e59b934c8ccf1301fa8ed1d36b4">ToString</a> () const override</td></tr>
<tr class="memdesc:aca966e59b934c8ccf1301fa8ed1d36b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the internals to a string.  <a href="#aca966e59b934c8ccf1301fa8ed1d36b4">More...</a><br/></td></tr>
<tr class="separator:aca966e59b934c8ccf1301fa8ed1d36b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a296a65d6d0a4148cb71cc6a0958bde59"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#a296a65d6d0a4148cb71cc6a0958bde59">SetIdString</a> (const std::string &amp;a_id) override</td></tr>
<tr class="memdesc:a296a65d6d0a4148cb71cc6a0958bde59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set string that identifies this interp class instance.  <a href="#a296a65d6d0a4148cb71cc6a0958bde59">More...</a><br/></td></tr>
<tr class="separator:a296a65d6d0a4148cb71cc6a0958bde59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf5464d0959c44b39d2a26397e31525"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#a4cf5464d0959c44b39d2a26397e31525">GetIdString</a> () const override</td></tr>
<tr class="memdesc:a4cf5464d0959c44b39d2a26397e31525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get string that identifies this interp class instance.  <a href="#a4cf5464d0959c44b39d2a26397e31525">More...</a><br/></td></tr>
<tr class="separator:a4cf5464d0959c44b39d2a26397e31525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b3657d29033724bb6f585a52a9c6b45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#a4b3657d29033724bb6f585a52a9c6b45">SetScalars</a> (const float *a_scalar, size_t a_n) override</td></tr>
<tr class="memdesc:a4b3657d29033724bb6f585a52a9c6b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the scalar values that will be used to do the interpolation.  <a href="#a4b3657d29033724bb6f585a52a9c6b45">More...</a><br/></td></tr>
<tr class="separator:a4b3657d29033724bb6f585a52a9c6b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c80070303cae01545c909219580e08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#af4c80070303cae01545c909219580e08">SetScalars</a> (<a class="elRef" doxygen="/home/travis/build/Aquaveo/xmsinterp/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore//" href="https://aquaveo.github.io/xmscore/boost__defines_8h.html#a37efc6913312f9271e2ea37f1acbc2dc">BSHP</a>&lt; std::vector&lt; float &gt;&gt; a_scalar)</td></tr>
<tr class="memdesc:af4c80070303cae01545c909219580e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the scalar values that will be used to do the interpolation.  <a href="#af4c80070303cae01545c909219580e08">More...</a><br/></td></tr>
<tr class="separator:af4c80070303cae01545c909219580e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a8bc3e2e027ca134877f3aa88b23d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#a88a8bc3e2e027ca134877f3aa88b23d0">SetPower</a> (double a_power) override</td></tr>
<tr class="memdesc:a88a8bc3e2e027ca134877f3aa88b23d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the exponent for the interpolation. By default the class does inverse distance squared weighting but the exponent can be changed to any value.  <a href="#a88a8bc3e2e027ca134877f3aa88b23d0">More...</a><br/></td></tr>
<tr class="separator:a88a8bc3e2e027ca134877f3aa88b23d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5e7543751ab81d1d46648a9acffec1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae5e7543751ab81d1d46648a9acffec1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#aae5e7543751ab81d1d46648a9acffec1">RecalcNodalFunc</a> ()</td></tr>
<tr class="memdesc:aae5e7543751ab81d1d46648a9acffec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recalculates the nodal function. This happens when the scalars change. <br/></td></tr>
<tr class="separator:aae5e7543751ab81d1d46648a9acffec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467e27bca94097b2f08214d8695c3125"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#a467e27bca94097b2f08214d8695c3125">SetSearchOpts</a> (int a_nNearestPoints, bool a_quad_oct_Search) override</td></tr>
<tr class="memdesc:a467e27bca94097b2f08214d8695c3125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the search options for how to find the nearest points to the interpolation point. The number of nearest points can be specified as well as whether to find the nearest points in each quadrant or octant.  <a href="#a467e27bca94097b2f08214d8695c3125">More...</a><br/></td></tr>
<tr class="separator:a467e27bca94097b2f08214d8695c3125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac513bcf9627f00929a739ed19b4cec"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#a1ac513bcf9627f00929a739ed19b4cec">InterpToPt</a> (const Pt3d &amp;a_pt, int a_idx) const </td></tr>
<tr class="memdesc:a1ac513bcf9627f00929a739ed19b4cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload to interpolate to the location specified by a_pt. The a_idx variable is used if the interpolation weights are being saved for later processing by the calling program.  <a href="#a1ac513bcf9627f00929a739ed19b4cec">More...</a><br/></td></tr>
<tr class="separator:a1ac513bcf9627f00929a739ed19b4cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e778c77863691c71b4fcc952bdedd97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#a9e778c77863691c71b4fcc952bdedd97">SetObserver</a> (<a class="elRef" doxygen="/home/travis/build/Aquaveo/xmsinterp/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore//" href="https://aquaveo.github.io/xmscore/boost__defines_8h.html#a37efc6913312f9271e2ea37f1acbc2dc">BSHP</a>&lt; <a class="elRef" doxygen="/home/travis/build/Aquaveo/xmsinterp/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore//" href="https://aquaveo.github.io/xmscore/classxms_1_1_observer.html">Observer</a> &gt; a_prog) override</td></tr>
<tr class="memdesc:a9e778c77863691c71b4fcc952bdedd97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the observer class so that feedback on the interpolation process can be received.  <a href="#a9e778c77863691c71b4fcc952bdedd97">More...</a><br/></td></tr>
<tr class="separator:a9e778c77863691c71b4fcc952bdedd97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6146dab4afc15a9cae681bf1ca3f5c67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#a6146dab4afc15a9cae681bf1ca3f5c67">ValFromWeights</a> (std::vector&lt; double &gt; &amp;a_w, std::vector&lt; int &gt; &amp;a_nPts, float &amp;a_val, int a_ptIdx, const Pt3d &amp;a_pt) const </td></tr>
<tr class="memdesc:a6146dab4afc15a9cae681bf1ca3f5c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a vector of weights, the interpolated value a_val is computed at the point a_pt.  <a href="#a6146dab4afc15a9cae681bf1ca3f5c67">More...</a><br/></td></tr>
<tr class="separator:a6146dab4afc15a9cae681bf1ca3f5c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a152be78d49b473101a31a8645a34073d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#a152be78d49b473101a31a8645a34073d">SetWeightCalcMethod</a> (<a class="el" href="classxms_1_1_interp_idw.html#a75db3e802021d0171f8a8e0077d9d0fc">InterpIdw::WeightEnum</a> a_) override</td></tr>
<tr class="memdesc:a152be78d49b473101a31a8645a34073d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the method for calculating the weights. The classic just uses 1/distance^exponent. The modified method uses another formulation based on the distance of the furtherest location from the interpolation pt.  <a href="#a152be78d49b473101a31a8645a34073d">More...</a><br/></td></tr>
<tr class="separator:a152be78d49b473101a31a8645a34073d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e713404bb178081c0c4f98ef541e8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#a95e713404bb178081c0c4f98ef541e8d">SetNodalFunction</a> (<a class="el" href="classxms_1_1_interp_idw.html#a9f0d45e41829c4a94b53dd336d086f4a">NodalFuncEnum</a> a_, int a_nNearest, bool a_quad_oct, <a class="elRef" doxygen="/home/travis/build/Aquaveo/xmsinterp/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore//" href="https://aquaveo.github.io/xmscore/boost__defines_8h.html#a37efc6913312f9271e2ea37f1acbc2dc">BSHP</a>&lt; <a class="elRef" doxygen="/home/travis/build/Aquaveo/xmsinterp/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore//" href="https://aquaveo.github.io/xmscore/classxms_1_1_observer.html">Observer</a> &gt; a_p) override</td></tr>
<tr class="memdesc:a95e713404bb178081c0c4f98ef541e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the type of nodal function as well as options for computing nodal functions.  <a href="#a95e713404bb178081c0c4f98ef541e8d">More...</a><br/></td></tr>
<tr class="separator:a95e713404bb178081c0c4f98ef541e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208c6b6ab2b19093e1f1d207b4b85091"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#a208c6b6ab2b19093e1f1d207b4b85091">CreateNodalFunctionPtr</a> (<a class="el" href="classxms_1_1_interp_idw.html#a9f0d45e41829c4a94b53dd336d086f4a">NodalFuncEnum</a> a_, int a_nNearest, bool a_quad_oct, <a class="elRef" doxygen="/home/travis/build/Aquaveo/xmsinterp/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore//" href="https://aquaveo.github.io/xmscore/boost__defines_8h.html#a37efc6913312f9271e2ea37f1acbc2dc">BSHP</a>&lt; <a class="elRef" doxygen="/home/travis/build/Aquaveo/xmsinterp/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore//" href="https://aquaveo.github.io/xmscore/classxms_1_1_observer.html">Observer</a> &gt; a_p)</td></tr>
<tr class="memdesc:a208c6b6ab2b19093e1f1d207b4b85091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the Nodal function class.  <a href="#a208c6b6ab2b19093e1f1d207b4b85091">More...</a><br/></td></tr>
<tr class="separator:a208c6b6ab2b19093e1f1d207b4b85091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02463323c9c0bb85366a3a0c3a78af1e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#a02463323c9c0bb85366a3a0c3a78af1e">ScalarFromNodalFunc</a> (int a_ptIdx, const Pt3d &amp;a_loc) const </td></tr>
<tr class="memdesc:a02463323c9c0bb85366a3a0c3a78af1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a scalar value based on the nodal function. When nodal functions are used then the scalar value used at each point depends on the location of the you are interpolating to.  <a href="#a02463323c9c0bb85366a3a0c3a78af1e">More...</a><br/></td></tr>
<tr class="separator:a02463323c9c0bb85366a3a0c3a78af1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a89798e64a57bd3674aa0191b05a1bfb6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89798e64a57bd3674aa0191b05a1bfb6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#a89798e64a57bd3674aa0191b05a1bfb6">m_2d</a></td></tr>
<tr class="memdesc:a89798e64a57bd3674aa0191b05a1bfb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag for computing distances in xy instead of xyz <br/></td></tr>
<tr class="separator:a89798e64a57bd3674aa0191b05a1bfb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedfc573a93a865157cba7d62e94c8396"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aedfc573a93a865157cba7d62e94c8396"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#aedfc573a93a865157cba7d62e94c8396">m_quadOctSearch</a></td></tr>
<tr class="memdesc:aedfc573a93a865157cba7d62e94c8396"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag for performing quadrant(2d) or octant (3d) searching for nearest pts <br/></td></tr>
<tr class="separator:aedfc573a93a865157cba7d62e94c8396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d8491cf7291c3aeaf0556a1d25bd06"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#a29d8491cf7291c3aeaf0556a1d25bd06">m_modifiedShepardWeights</a></td></tr>
<tr class="separator:a29d8491cf7291c3aeaf0556a1d25bd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5231a2f3ae69e877a135e1c1631561"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#a3b5231a2f3ae69e877a135e1c1631561">m_nNearestPts</a></td></tr>
<tr class="separator:a3b5231a2f3ae69e877a135e1c1631561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725548983086139fc68612438afe1b4e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#a725548983086139fc68612438afe1b4e">m_power</a></td></tr>
<tr class="separator:a725548983086139fc68612438afe1b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2e2caf2bf4fa2e2449c4e6ad314ddf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f2e2caf2bf4fa2e2449c4e6ad314ddf"></a>
<a class="elRef" doxygen="/home/travis/build/Aquaveo/xmsinterp/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore//" href="https://aquaveo.github.io/xmscore/boost__defines_8h.html#a37efc6913312f9271e2ea37f1acbc2dc">BSHP</a>&lt; <a class="el" href="classxms_1_1_gm_pt_search.html">GmPtSearch</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#a9f2e2caf2bf4fa2e2449c4e6ad314ddf">m_ptSearch</a></td></tr>
<tr class="memdesc:a9f2e2caf2bf4fa2e2449c4e6ad314ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class used to find nearest points. <br/></td></tr>
<tr class="separator:a9f2e2caf2bf4fa2e2449c4e6ad314ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1175fedcb9c6d8e7d4a80e2aeac9a8dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1175fedcb9c6d8e7d4a80e2aeac9a8dd"></a>
<a class="elRef" doxygen="/home/travis/build/Aquaveo/xmsinterp/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore//" href="https://aquaveo.github.io/xmscore/boost__defines_8h.html#a37efc6913312f9271e2ea37f1acbc2dc">BSHP</a>&lt; std::vector&lt; Pt3d &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#a1175fedcb9c6d8e7d4a80e2aeac9a8dd">m_pts</a></td></tr>
<tr class="memdesc:a1175fedcb9c6d8e7d4a80e2aeac9a8dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Points used to interpolate. <br/></td></tr>
<tr class="separator:a1175fedcb9c6d8e7d4a80e2aeac9a8dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a192580cb209683ec63620b4915677e88"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a192580cb209683ec63620b4915677e88"></a>
<a class="elRef" doxygen="/home/travis/build/Aquaveo/xmsinterp/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore//" href="https://aquaveo.github.io/xmscore/boost__defines_8h.html#a37efc6913312f9271e2ea37f1acbc2dc">BSHP</a>&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#a192580cb209683ec63620b4915677e88">m_tris</a></td></tr>
<tr class="memdesc:a192580cb209683ec63620b4915677e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">triangles ignored by idw <br/></td></tr>
<tr class="separator:a192580cb209683ec63620b4915677e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb79efd0ab17fb6c6ea2f331a31d5abc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb79efd0ab17fb6c6ea2f331a31d5abc"></a>
<a class="elRef" doxygen="/home/travis/build/Aquaveo/xmsinterp/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore//" href="https://aquaveo.github.io/xmscore/boost__defines_8h.html#a37efc6913312f9271e2ea37f1acbc2dc">BSHP</a>&lt; std::vector&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#aeb79efd0ab17fb6c6ea2f331a31d5abc">m_scalarFrom</a></td></tr>
<tr class="memdesc:aeb79efd0ab17fb6c6ea2f331a31d5abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalars at the points used to interpolate. <br/></td></tr>
<tr class="separator:aeb79efd0ab17fb6c6ea2f331a31d5abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe74f3c6076182c96f80756c94efa9e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2fe74f3c6076182c96f80756c94efa9e"></a>
<a class="elRef" doxygen="/home/travis/build/Aquaveo/xmsinterp/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore//" href="https://aquaveo.github.io/xmscore/boost__defines_8h.html#a37efc6913312f9271e2ea37f1acbc2dc">BSHP</a>&lt; <a class="el" href="classxms_1_1_nodal_func.html">NodalFunc</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#a2fe74f3c6076182c96f80756c94efa9e">m_nodalFunc</a></td></tr>
<tr class="memdesc:a2fe74f3c6076182c96f80756c94efa9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nodal function (constant, gradient plane, quadratic) <br/></td></tr>
<tr class="separator:a2fe74f3c6076182c96f80756c94efa9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d7651f0110ac2aed65074dadc65fc4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90d7651f0110ac2aed65074dadc65fc4"></a>
<a class="elRef" doxygen="/home/travis/build/Aquaveo/xmsinterp/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore//" href="https://aquaveo.github.io/xmscore/boost__defines_8h.html#a37efc6913312f9271e2ea37f1acbc2dc">BSHP</a>&lt; <a class="elRef" doxygen="/home/travis/build/Aquaveo/xmsinterp/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore//" href="https://aquaveo.github.io/xmscore/classxms_1_1_observer.html">Observer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#a90d7651f0110ac2aed65074dadc65fc4">m_prog</a></td></tr>
<tr class="memdesc:a90d7651f0110ac2aed65074dadc65fc4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="elRef" doxygen="/home/travis/build/Aquaveo/xmsinterp/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore//" href="https://aquaveo.github.io/xmscore/classxms_1_1_observer.html">Observer</a> that reports status of interpolation process. <br/></td></tr>
<tr class="separator:a90d7651f0110ac2aed65074dadc65fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef1ca833d7e5738d07a7ca05a22411c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef1ca833d7e5738d07a7ca05a22411c4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#aef1ca833d7e5738d07a7ca05a22411c4">m_saveWeights</a></td></tr>
<tr class="memdesc:aef1ca833d7e5738d07a7ca05a22411c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag for saving the interpolation weights <br/></td></tr>
<tr class="separator:aef1ca833d7e5738d07a7ca05a22411c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7343722fc68233fdeb0b401753808a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7343722fc68233fdeb0b401753808a8"></a>
std::vector&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#ab7343722fc68233fdeb0b401753808a8">m_ptIdx</a></td></tr>
<tr class="memdesc:ab7343722fc68233fdeb0b401753808a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">pt indexes for saving weights <br/></td></tr>
<tr class="separator:ab7343722fc68233fdeb0b401753808a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d04093d8f1538299dcf5d744dc8c47b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d04093d8f1538299dcf5d744dc8c47b"></a>
std::vector&lt; std::vector<br class="typebreak"/>
&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#a6d04093d8f1538299dcf5d744dc8c47b">m_weights</a></td></tr>
<tr class="memdesc:a6d04093d8f1538299dcf5d744dc8c47b"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculated weights for saving weights <br/></td></tr>
<tr class="separator:a6d04093d8f1538299dcf5d744dc8c47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3602605e9366da768f4b21196e9fb1ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3602605e9366da768f4b21196e9fb1ce"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#a3602605e9366da768f4b21196e9fb1ce">m_trunc</a></td></tr>
<tr class="memdesc:a3602605e9366da768f4b21196e9fb1ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag to indicate if truncation is on <br/></td></tr>
<tr class="separator:a3602605e9366da768f4b21196e9fb1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6a28fea5b353155205dbd1686257e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e6a28fea5b353155205dbd1686257e8"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#a8e6a28fea5b353155205dbd1686257e8">m_truncMax</a></td></tr>
<tr class="memdesc:a8e6a28fea5b353155205dbd1686257e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum truncation value. All interpolated values will be &lt;=. <br/></td></tr>
<tr class="separator:a8e6a28fea5b353155205dbd1686257e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb5d0d1fd76f234cef91aa4fd493020"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5eb5d0d1fd76f234cef91aa4fd493020"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#a5eb5d0d1fd76f234cef91aa4fd493020">m_truncMin</a></td></tr>
<tr class="memdesc:a5eb5d0d1fd76f234cef91aa4fd493020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum truncation value. All interpolated values will be &gt;=. <br/></td></tr>
<tr class="separator:a5eb5d0d1fd76f234cef91aa4fd493020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae59e8cfcd72425119a286bc7b52a207"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae59e8cfcd72425119a286bc7b52a207"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#aae59e8cfcd72425119a286bc7b52a207">m_multiThread</a></td></tr>
<tr class="memdesc:aae59e8cfcd72425119a286bc7b52a207"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag to indicate if multithreading should be used when interpolating <br/></td></tr>
<tr class="separator:aae59e8cfcd72425119a286bc7b52a207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031fa6f2aeca5ae3e15cb01c42b8dae6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a031fa6f2aeca5ae3e15cb01c42b8dae6"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw_impl.html#a031fa6f2aeca5ae3e15cb01c42b8dae6">m_idString</a></td></tr>
<tr class="memdesc:a031fa6f2aeca5ae3e15cb01c42b8dae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">identification for comparison with other Interp classes <br/></td></tr>
<tr class="separator:a031fa6f2aeca5ae3e15cb01c42b8dae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classxms_1_1_interp_idw"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classxms_1_1_interp_idw')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classxms_1_1_interp_idw.html">xms::InterpIdw</a></td></tr>
<tr class="memitem:a75db3e802021d0171f8a8e0077d9d0fc inherit pub_types_classxms_1_1_interp_idw"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw.html#a75db3e802021d0171f8a8e0077d9d0fc">WeightEnum</a> { <b>CLASSIC</b>, 
<b>MODIFIED</b>
 }</td></tr>
<tr class="memdesc:a75db3e802021d0171f8a8e0077d9d0fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weight calculation method enumeration. <br/></td></tr>
<tr class="separator:a75db3e802021d0171f8a8e0077d9d0fc inherit pub_types_classxms_1_1_interp_idw"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0d45e41829c4a94b53dd336d086f4a inherit pub_types_classxms_1_1_interp_idw"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw.html#a9f0d45e41829c4a94b53dd336d086f4a">NodalFuncEnum</a> { <b>CONSTANT</b>, 
<b>GRAD_PLANE</b>, 
<b>QUADRATIC</b>
 }</td></tr>
<tr class="memdesc:a9f0d45e41829c4a94b53dd336d086f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nodal fuction type enumeration. <br/></td></tr>
<tr class="separator:a9f0d45e41829c4a94b53dd336d086f4a inherit pub_types_classxms_1_1_interp_idw"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classxms_1_1_interp_idw"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classxms_1_1_interp_idw')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classxms_1_1_interp_idw.html">xms::InterpIdw</a></td></tr>
<tr class="memitem:ada220d36126708676e57d6b9eac2f3d7 inherit pub_static_methods_classxms_1_1_interp_idw"><td class="memItemLeft" align="right" valign="top">static <a class="elRef" doxygen="/home/travis/build/Aquaveo/xmsinterp/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore//" href="https://aquaveo.github.io/xmscore/boost__defines_8h.html#a37efc6913312f9271e2ea37f1acbc2dc">BSHP</a>&lt; <a class="el" href="classxms_1_1_interp_idw.html">InterpIdw</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxms_1_1_interp_idw.html#ada220d36126708676e57d6b9eac2f3d7">New</a> ()</td></tr>
<tr class="memdesc:ada220d36126708676e57d6b9eac2f3d7 inherit pub_static_methods_classxms_1_1_interp_idw"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="classxms_1_1_interp_idw.html" title="Class that performs inverse distance weighted interpolation. ">InterpIdw</a> class.  <a href="#ada220d36126708676e57d6b9eac2f3d7">More...</a><br/></td></tr>
<tr class="separator:ada220d36126708676e57d6b9eac2f3d7 inherit pub_static_methods_classxms_1_1_interp_idw"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implementation of <a class="el" href="classxms_1_1_interp_idw.html" title="Class that performs inverse distance weighted interpolation. ">InterpIdw</a> class. </p>
<p>Inverse distance weighted interpolation class.</p>
<div class="image">
<img src="idw_const.png" alt="idw_const.png"/>
</div>
 
<p>Definition at line <a class="el" href="_interp_idw_8cpp_source.html#l00048">48</a> of file <a class="el" href="_interp_idw_8cpp_source.html">InterpIdw.cpp</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a208c6b6ab2b19093e1f1d207b4b85091"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xms::InterpIdwImpl::CreateNodalFunctionPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxms_1_1_interp_idw.html#a9f0d45e41829c4a94b53dd336d086f4a">NodalFuncEnum</a>&#160;</td>
          <td class="paramname"><em>a_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a_nNearest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a_quad_oct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="/home/travis/build/Aquaveo/xmsinterp/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore//" href="https://aquaveo.github.io/xmscore/boost__defines_8h.html#a37efc6913312f9271e2ea37f1acbc2dc">BSHP</a>&lt; <a class="elRef" doxygen="/home/travis/build/Aquaveo/xmsinterp/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore//" href="https://aquaveo.github.io/xmscore/classxms_1_1_observer.html">Observer</a> &gt;&#160;</td>
          <td class="paramname"><em>a_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the Nodal function class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_</td><td>Type of nodal function: gradient plane, quadratic </td></tr>
    <tr><td class="paramname">a_nNearest</td><td>Number of nearest points to use when calculating nodal functions. </td></tr>
    <tr><td class="paramname">a_quad_oct</td><td>flag to turn on/off quadrant or octant searching for nearest number of points. </td></tr>
    <tr><td class="paramname">a_p</td><td><a class="elRef" doxygen="/home/travis/build/Aquaveo/xmsinterp/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore//" href="https://aquaveo.github.io/xmscore/classxms_1_1_observer.html">Observer</a> for reporting progress of nodal function calculations. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_interp_idw_8cpp_source.html#l00655">655</a> of file <a class="el" href="_interp_idw_8cpp_source.html">InterpIdw.cpp</a>.</p>

<p>References <a class="el" href="_interp_idw_8cpp_source.html#l00146">m_2d</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00149">m_modifiedShepardWeights</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00160">m_nodalFunc</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00155">m_power</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00157">m_pts</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00156">m_ptSearch</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00159">m_scalarFrom</a>, and <a class="el" href="_nodal_func_8cpp_source.html#l00169">xms::NodalFunc::New()</a>.</p>

<p>Referenced by <a class="el" href="_interp_idw_8cpp_source.html#l00634">SetNodalFunction()</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00895">InterpIdwUnitTests::testErrors()</a>, and <a class="el" href="_interp_idw_8cpp_source.html#l00918">InterpIdwUnitTests::testErrors2()</a>.</p>

</div>
</div>
<a class="anchor" id="a4cf5464d0959c44b39d2a26397e31525"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string xms::InterpIdwImpl::GetIdString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get string that identifies this interp class instance. </p>
<dl class="section return"><dt>Returns</dt><dd>a_id: The ID string. </dd></dl>

<p>Definition at line <a class="el" href="_interp_idw_8cpp_source.html#l00574">574</a> of file <a class="el" href="_interp_idw_8cpp_source.html">InterpIdw.cpp</a>.</p>

<p>References <a class="el" href="_interp_idw_8cpp_source.html#l00169">m_idString</a>.</p>

</div>
</div>
<a class="anchor" id="af674b8955a7ecebacc2d7c4a8cfe7bce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/home/travis/build/Aquaveo/xmsinterp/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore//" href="https://aquaveo.github.io/xmscore/boost__defines_8h.html#a37efc6913312f9271e2ea37f1acbc2dc">BSHP</a>&lt; std::vector&lt; Pt3d &gt; &gt; xms::InterpIdwImpl::GetPts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns shared pointer to points vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to points vector. </dd></dl>

<p>Definition at line <a class="el" href="_interp_idw_8cpp_source.html#l00461">461</a> of file <a class="el" href="_interp_idw_8cpp_source.html">InterpIdw.cpp</a>.</p>

<p>References <a class="el" href="_interp_idw_8cpp_source.html#l00157">m_pts</a>.</p>

</div>
</div>
<a class="anchor" id="a2f49dccc1544e1e04b16358e458a94cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/home/travis/build/Aquaveo/xmsinterp/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore//" href="https://aquaveo.github.io/xmscore/boost__defines_8h.html#a37efc6913312f9271e2ea37f1acbc2dc">BSHP</a>&lt; std::vector&lt; int &gt; &gt; xms::InterpIdwImpl::GetTris </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns shared pointer to triangles vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to triangles vector. </dd></dl>

<p>Definition at line <a class="el" href="_interp_idw_8cpp_source.html#l00469">469</a> of file <a class="el" href="_interp_idw_8cpp_source.html">InterpIdw.cpp</a>.</p>

<p>References <a class="el" href="_interp_idw_8cpp_source.html#l00158">m_tris</a>.</p>

</div>
</div>
<a class="anchor" id="a0b6241d646bacd9de44bcf1e346e094d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float xms::InterpIdwImpl::InterpToPt </td>
          <td>(</td>
          <td class="paramtype">const Pt3d &amp;&#160;</td>
          <td class="paramname"><em>a_pt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpolates to the location specified by a_pt and returns the value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_pt</td><td>The location of the interpolation point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interpolated value. </dd></dl>

<p>Definition at line <a class="el" href="_interp_idw_8cpp_source.html#l00375">375</a> of file <a class="el" href="_interp_idw_8cpp_source.html">InterpIdw.cpp</a>.</p>

<p>References <a class="elRef" doxygen="/home/travis/build/Aquaveo/xmsinterp/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore//" href="https://aquaveo.github.io/xmscore/xmstype_8h.html#a8a1e225f1a26f97086b87346b57b4c16">XM_NONE</a>.</p>

<p>Referenced by <a class="el" href="_interp_idw_8cpp_source.html#l00420">InterpToPts()</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00918">InterpIdwUnitTests::testErrors2()</a>, and <a class="el" href="_interp_idw_8cpp_source.html#l00081">xms::InterpIdwImpl::InterpThread::Worker()</a>.</p>

</div>
</div>
<a class="anchor" id="a1ac513bcf9627f00929a739ed19b4cec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float xms::InterpIdwImpl::InterpToPt </td>
          <td>(</td>
          <td class="paramtype">const Pt3d &amp;&#160;</td>
          <td class="paramname"><em>a_pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>overload to interpolate to the location specified by a_pt. The a_idx variable is used if the interpolation weights are being saved for later processing by the calling program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_pt</td><td>The location of the interpolation point. </td></tr>
    <tr><td class="paramname">a_idx</td><td>Index related to the location a_pt used to later process interpolation weights related to a_pt. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interpolated value. </dd></dl>

<p>Definition at line <a class="el" href="_interp_idw_8cpp_source.html#l00388">388</a> of file <a class="el" href="_interp_idw_8cpp_source.html">InterpIdw.cpp</a>.</p>

<p>References <a class="el" href="_interp_idw_8cpp_source.html#l00493">InterpWeights()</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00162">m_saveWeights</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00159">m_scalarFrom</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00165">m_trunc</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00166">m_truncMax</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00167">m_truncMin</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00590">ValFromWeights()</a>, and <a class="elRef" doxygen="/home/travis/build/Aquaveo/xmsinterp/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore//" href="https://aquaveo.github.io/xmscore/_xm_error_8h.html#a7a57f398a574f7027ce3250021608823">XM_ENSURE_FALSE</a>.</p>

</div>
</div>
<a class="anchor" id="accf865202659ed8b760a1524b00f7593"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void xms::InterpIdwImpl::InterpToPts </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Pt3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_pts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_scalars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpolates to an array of points and fills in an array of scalars. This method will run in parallel using multiple threads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_pts</td><td>Array of points to interpolate to. </td></tr>
    <tr><td class="paramname">a_scalars</td><td>Array of scalar values that is filled in by this method. a_scalars will be the same size as a_pts and each value corresponds to the interpolated value at the respective location in the a_pts array. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_interp_idw_8cpp_source.html#l00420">420</a> of file <a class="el" href="_interp_idw_8cpp_source.html">InterpIdw.cpp</a>.</p>

<p>References <a class="el" href="_interp_idw_8cpp_source.html#l00375">InterpToPt()</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00168">m_multiThread</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00161">m_prog</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00162">m_saveWeights</a>, and <a class="el" href="_thread_mgr_8cpp_source.html#l00106">xms::ThreadMgr::New()</a>.</p>

</div>
</div>
<a class="anchor" id="a475b892911b0603b88c01efef172ecd9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void xms::InterpIdwImpl::InterpWeights </td>
          <td>(</td>
          <td class="paramtype">const Pt3d &amp;&#160;</td>
          <td class="paramname"><em>a_pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_nPts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a location and an array of points the weights associated with array of points are calculated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_pt</td><td>Location of the interpolation point </td></tr>
    <tr><td class="paramname">a_nPts</td><td>Vector of indices indicating the location in the m_pts vector of the nearest points to a_pt. </td></tr>
    <tr><td class="paramname">a_w</td><td>Vector weights associated with the nearest points to a_pt. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_interp_idw_8cpp_source.html#l00493">493</a> of file <a class="el" href="_interp_idw_8cpp_source.html">InterpIdw.cpp</a>.</p>

<p>References <a class="el" href="_interp_idw_8cpp_source.html#l00146">m_2d</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00149">m_modifiedShepardWeights</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00151">m_nNearestPts</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00155">m_power</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00157">m_pts</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00156">m_ptSearch</a>, and <a class="el" href="_interp_idw_8cpp_source.html#l00148">m_quadOctSearch</a>.</p>

<p>Referenced by <a class="el" href="_interp_idw_8cpp_source.html#l00388">InterpToPt()</a>.</p>

</div>
</div>
<a class="anchor" id="a02463323c9c0bb85366a3a0c3a78af1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double xms::InterpIdwImpl::ScalarFromNodalFunc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a_ptIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Pt3d &amp;&#160;</td>
          <td class="paramname"><em>a_loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a scalar value based on the nodal function. When nodal functions are used then the scalar value used at each point depends on the location of the you are interpolating to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_ptIdx</td><td>The index of one of the points being used to interpolate (index into m_pts). </td></tr>
    <tr><td class="paramname">a_loc</td><td>The location of the point we are interpolating to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Scalar value at a_ptIdx adjusted by the nodal function. </dd></dl>

<p>Definition at line <a class="el" href="_interp_idw_8cpp_source.html#l00672">672</a> of file <a class="el" href="_interp_idw_8cpp_source.html">InterpIdw.cpp</a>.</p>

<p>References <a class="el" href="_interp_idw_8cpp_source.html#l00160">m_nodalFunc</a>, and <a class="el" href="_interp_idw_8cpp_source.html#l00159">m_scalarFrom</a>.</p>

<p>Referenced by <a class="el" href="_interp_idw_8cpp_source.html#l00590">ValFromWeights()</a>.</p>

</div>
</div>
<a class="anchor" id="a296a65d6d0a4148cb71cc6a0958bde59"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void xms::InterpIdwImpl::SetIdString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set string that identifies this interp class instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_id</td><td>The ID string. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_interp_idw_8cpp_source.html#l00566">566</a> of file <a class="el" href="_interp_idw_8cpp_source.html">InterpIdw.cpp</a>.</p>

<p>References <a class="el" href="_interp_idw_8cpp_source.html#l00169">m_idString</a>.</p>

</div>
</div>
<a class="anchor" id="a95ea5690b1c3e9de099ce4478e138cca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void xms::InterpIdwImpl::SetMultiThreading </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sets a flag to use (or not) multi-threading when interpolating </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_</td><td>flag: true will use multi-threading and false will not. The default setting for the class is to use multi-threading. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_interp_idw_8cpp_source.html#l00113">113</a> of file <a class="el" href="_interp_idw_8cpp_source.html">InterpIdw.cpp</a>.</p>

<p>References <a class="el" href="_interp_idw_8cpp_source.html#l00168">m_multiThread</a>.</p>

</div>
</div>
<a class="anchor" id="a95e713404bb178081c0c4f98ef541e8d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void xms::InterpIdwImpl::SetNodalFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxms_1_1_interp_idw.html#a9f0d45e41829c4a94b53dd336d086f4a">NodalFuncEnum</a>&#160;</td>
          <td class="paramname"><em>a_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a_nNearest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a_quad_oct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="/home/travis/build/Aquaveo/xmsinterp/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore//" href="https://aquaveo.github.io/xmscore/boost__defines_8h.html#a37efc6913312f9271e2ea37f1acbc2dc">BSHP</a>&lt; <a class="elRef" doxygen="/home/travis/build/Aquaveo/xmsinterp/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore//" href="https://aquaveo.github.io/xmscore/classxms_1_1_observer.html">Observer</a> &gt;&#160;</td>
          <td class="paramname"><em>a_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the type of nodal function as well as options for computing nodal functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_</td><td>The nodal function methodology: constant (0), gradient plane (1), quadratic (2). </td></tr>
    <tr><td class="paramname">a_nNearest</td><td>The nearest number of points to use when calculating the nodal functions. </td></tr>
    <tr><td class="paramname">a_quad_oct</td><td>Find the nearest number of points in each quadrant (2d) or octant (3d) when computing nodal functions. </td></tr>
    <tr><td class="paramname">a_p</td><td><a class="elRef" doxygen="/home/travis/build/Aquaveo/xmsinterp/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore//" href="https://aquaveo.github.io/xmscore/classxms_1_1_progress.html">Progress</a> bar to give user feedback. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_interp_idw_8cpp_source.html#l00634">634</a> of file <a class="el" href="_interp_idw_8cpp_source.html">InterpIdw.cpp</a>.</p>

<p>References <a class="el" href="_interp_idw_8cpp_source.html#l00655">CreateNodalFunctionPtr()</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00156">m_ptSearch</a>, and <a class="el" href="_interp_idw_8cpp_source.html#l00159">m_scalarFrom</a>.</p>

<p>Referenced by <a class="el" href="_interp_idw_8cpp_source.html#l00895">InterpIdwUnitTests::testErrors()</a>, and <a class="el" href="_interp_idw_8cpp_source.html#l00918">InterpIdwUnitTests::testErrors2()</a>.</p>

</div>
</div>
<a class="anchor" id="a9e778c77863691c71b4fcc952bdedd97"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void xms::InterpIdwImpl::SetObserver </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="/home/travis/build/Aquaveo/xmsinterp/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore//" href="https://aquaveo.github.io/xmscore/boost__defines_8h.html#a37efc6913312f9271e2ea37f1acbc2dc">BSHP</a>&lt; <a class="elRef" doxygen="/home/travis/build/Aquaveo/xmsinterp/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore//" href="https://aquaveo.github.io/xmscore/classxms_1_1_observer.html">Observer</a> &gt;&#160;</td>
          <td class="paramname"><em>a_prog</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the observer class so that feedback on the interpolation process can be received. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_prog</td><td>The observer. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_interp_idw_8cpp_source.html#l00128">128</a> of file <a class="el" href="_interp_idw_8cpp_source.html">InterpIdw.cpp</a>.</p>

<p>References <a class="el" href="_interp_idw_8cpp_source.html#l00161">m_prog</a>.</p>

</div>
</div>
<a class="anchor" id="a88a8bc3e2e027ca134877f3aa88b23d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void xms::InterpIdwImpl::SetPower </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a_power</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the exponent for the interpolation. By default the class does inverse distance squared weighting but the exponent can be changed to any value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_power</td><td>the exponent used to compute the point weights 1 / distance^a_power </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_interp_idw_8cpp_source.html#l00341">341</a> of file <a class="el" href="_interp_idw_8cpp_source.html">InterpIdw.cpp</a>.</p>

<p>References <a class="el" href="_interp_idw_8cpp_source.html#l00160">m_nodalFunc</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00155">m_power</a>, and <a class="elRef" doxygen="/home/travis/build/Aquaveo/xmsinterp/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore//" href="https://aquaveo.github.io/xmscore/_xm_error_8h.html#a3dc5059ab2a87bfa4876b29ca6567376">XM_ENSURE_TRUE</a>.</p>

</div>
</div>
<a class="anchor" id="ae4d04a94ccc0c154d0a393121e24185e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void xms::InterpIdwImpl::SetPtActivity </td>
          <td>(</td>
          <td class="paramtype">DynBitset &amp;&#160;</td>
          <td class="paramname"><em>a_activity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the activity on the point being used to interpolate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_activity</td><td>Bitset of point activity. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_interp_idw_8cpp_source.html#l00453">453</a> of file <a class="el" href="_interp_idw_8cpp_source.html">InterpIdw.cpp</a>.</p>

<p>References <a class="el" href="_interp_idw_8cpp_source.html#l00156">m_ptSearch</a>.</p>

</div>
</div>
<a class="anchor" id="a2d4b1e66423c71e58b71c69132525aa4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void xms::InterpIdwImpl::SetPts </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="/home/travis/build/Aquaveo/xmsinterp/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore//" href="https://aquaveo.github.io/xmscore/boost__defines_8h.html#a37efc6913312f9271e2ea37f1acbc2dc">BSHP</a>&lt; std::vector&lt; Pt3d &gt;&gt;&#160;</td>
          <td class="paramname"><em>a_pts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a_2d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the points that will be used to do the interpolation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_pts</td><td>array of the point locations </td></tr>
    <tr><td class="paramname">a_2d</td><td>indicates if the class will do 2D or 3D interpolation </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_interp_idw_8cpp_source.html#l00298">298</a> of file <a class="el" href="_interp_idw_8cpp_source.html">InterpIdw.cpp</a>.</p>

<p>References <a class="el" href="_interp_idw_8cpp_source.html#l00146">m_2d</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00157">m_pts</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00156">m_ptSearch</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00159">m_scalarFrom</a>, and <a class="el" href="_gm_pt_search_8cpp_source.html#l00236">xms::GmPtSearch::New()</a>.</p>

<p>Referenced by <a class="el" href="_interp_idw_8cpp_source.html#l00288">SetPtsTris()</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00895">InterpIdwUnitTests::testErrors()</a>, and <a class="el" href="_interp_idw_8cpp_source.html#l00918">InterpIdwUnitTests::testErrors2()</a>.</p>

</div>
</div>
<a class="anchor" id="af34c7cead7fc8a591985593e3fc0d000"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void xms::InterpIdwImpl::SetPtsTris </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="/home/travis/build/Aquaveo/xmsinterp/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore//" href="https://aquaveo.github.io/xmscore/boost__defines_8h.html#a37efc6913312f9271e2ea37f1acbc2dc">BSHP</a>&lt; VecPt3d &gt;&#160;</td>
          <td class="paramname"><em>a_pts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="/home/travis/build/Aquaveo/xmsinterp/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore//" href="https://aquaveo.github.io/xmscore/boost__defines_8h.html#a37efc6913312f9271e2ea37f1acbc2dc">BSHP</a>&lt; VecInt &gt;&#160;</td>
          <td class="paramname"><em>a_tris</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the points that will be used to do the interpolation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_pts</td><td>array of the point locations </td></tr>
    <tr><td class="paramname">a_tris</td><td>triangles </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_interp_idw_8cpp_source.html#l00288">288</a> of file <a class="el" href="_interp_idw_8cpp_source.html">InterpIdw.cpp</a>.</p>

<p>References <a class="el" href="_interp_idw_8cpp_source.html#l00158">m_tris</a>, and <a class="el" href="_interp_idw_8cpp_source.html#l00298">SetPts()</a>.</p>

</div>
</div>
<a class="anchor" id="ad8e7e3a8ff23af9ca36cec3a9deed4f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void xms::InterpIdwImpl::SetSaveWeights </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sets a flag to save the weights computed by the interpolation </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_</td><td>flag: true will save weights and false will no </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_interp_idw_8cpp_source.html#l00105">105</a> of file <a class="el" href="_interp_idw_8cpp_source.html">InterpIdw.cpp</a>.</p>

<p>References <a class="el" href="_interp_idw_8cpp_source.html#l00162">m_saveWeights</a>.</p>

</div>
</div>
<a class="anchor" id="a4b3657d29033724bb6f585a52a9c6b45"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void xms::InterpIdwImpl::SetScalars </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>a_scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>a_n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the scalar values that will be used to do the interpolation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_scalar</td><td>array of scalar values </td></tr>
    <tr><td class="paramname">a_n</td><td>size of the a_scalar array </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_interp_idw_8cpp_source.html#l00319">319</a> of file <a class="el" href="_interp_idw_8cpp_source.html">InterpIdw.cpp</a>.</p>

<p>References <a class="el" href="_interp_idw_8cpp_source.html#l00159">m_scalarFrom</a>, and <a class="el" href="_interp_idw_8cpp_source.html#l00349">RecalcNodalFunc()</a>.</p>

<p>Referenced by <a class="el" href="_interp_idw_8cpp_source.html#l00895">InterpIdwUnitTests::testErrors()</a>, and <a class="el" href="_interp_idw_8cpp_source.html#l00918">InterpIdwUnitTests::testErrors2()</a>.</p>

</div>
</div>
<a class="anchor" id="af4c80070303cae01545c909219580e08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xms::InterpIdwImpl::SetScalars </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="/home/travis/build/Aquaveo/xmsinterp/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore//" href="https://aquaveo.github.io/xmscore/boost__defines_8h.html#a37efc6913312f9271e2ea37f1acbc2dc">BSHP</a>&lt; std::vector&lt; float &gt;&gt;&#160;</td>
          <td class="paramname"><em>a_scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the scalar values that will be used to do the interpolation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_scalar</td><td>array of scalar values </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_interp_idw_8cpp_source.html#l00329">329</a> of file <a class="el" href="_interp_idw_8cpp_source.html">InterpIdw.cpp</a>.</p>

<p>References <a class="el" href="_interp_idw_8cpp_source.html#l00159">m_scalarFrom</a>, and <a class="el" href="_interp_idw_8cpp_source.html#l00349">RecalcNodalFunc()</a>.</p>

</div>
</div>
<a class="anchor" id="a467e27bca94097b2f08214d8695c3125"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void xms::InterpIdwImpl::SetSearchOpts </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a_nNearestPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a_quad_oct_Search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the search options for how to find the nearest points to the interpolation point. The number of nearest points can be specified as well as whether to find the nearest points in each quadrant or octant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_nNearestPoints</td><td>the number of nearest points to the interpolation point. These points are used to do the interpolation. </td></tr>
    <tr><td class="paramname">a_quad_oct_Search</td><td>specifies if the search criterion should find the nearest points in each quadrant (2d) or octant (3d) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_interp_idw_8cpp_source.html#l00365">365</a> of file <a class="el" href="_interp_idw_8cpp_source.html">InterpIdw.cpp</a>.</p>

<p>References <a class="el" href="_interp_idw_8cpp_source.html#l00151">m_nNearestPts</a>, and <a class="el" href="_interp_idw_8cpp_source.html#l00148">m_quadOctSearch</a>.</p>

</div>
</div>
<a class="anchor" id="a3360ed1fa84ea3addbb31580c4cfbb77"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void xms::InterpIdwImpl::SetTrunc </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a_sMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a_sMin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the truncation values for the interpolation and turn on truncation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_sMax</td><td>The maximum value for truncation. </td></tr>
    <tr><td class="paramname">a_sMin</td><td>The minimum value for truncation. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_interp_idw_8cpp_source.html#l00479">479</a> of file <a class="el" href="_interp_idw_8cpp_source.html">InterpIdw.cpp</a>.</p>

<p>References <a class="el" href="_interp_idw_8cpp_source.html#l00165">m_trunc</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00166">m_truncMax</a>, and <a class="el" href="_interp_idw_8cpp_source.html#l00167">m_truncMin</a>.</p>

</div>
</div>
<a class="anchor" id="a152be78d49b473101a31a8645a34073d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void xms::InterpIdwImpl::SetWeightCalcMethod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxms_1_1_interp_idw.html#a75db3e802021d0171f8a8e0077d9d0fc">InterpIdw::WeightEnum</a>&#160;</td>
          <td class="paramname"><em>a_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the method for calculating the weights. The classic just uses 1/distance^exponent. The modified method uses another formulation based on the distance of the furtherest location from the interpolation pt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_</td><td>The weight calculation method. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_interp_idw_8cpp_source.html#l00614">614</a> of file <a class="el" href="_interp_idw_8cpp_source.html">InterpIdw.cpp</a>.</p>

<p>References <a class="el" href="_interp_idw_8cpp_source.html#l00149">m_modifiedShepardWeights</a>.</p>

</div>
</div>
<a class="anchor" id="aca966e59b934c8ccf1301fa8ed1d36b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string xms::InterpIdwImpl::ToString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the internals to a string. </p>
<dl class="section return"><dt>Returns</dt><dd>The string. </dd></dl>

<p>Definition at line <a class="el" href="_interp_idw_8cpp_source.html#l00527">527</a> of file <a class="el" href="_interp_idw_8cpp_source.html">InterpIdw.cpp</a>.</p>

<p>References <a class="el" href="_interp_idw_8cpp_source.html#l00146">m_2d</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00149">m_modifiedShepardWeights</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00151">m_nNearestPts</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00160">m_nodalFunc</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00155">m_power</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00163">m_ptIdx</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00157">m_pts</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00156">m_ptSearch</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00148">m_quadOctSearch</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00162">m_saveWeights</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00159">m_scalarFrom</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00158">m_tris</a>, and <a class="el" href="_interp_idw_8cpp_source.html#l00164">m_weights</a>.</p>

</div>
</div>
<a class="anchor" id="a6146dab4afc15a9cae681bf1ca3f5c67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xms::InterpIdwImpl::ValFromWeights </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_nPts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>a_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a_ptIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Pt3d &amp;&#160;</td>
          <td class="paramname"><em>a_pt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a vector of weights, the interpolated value a_val is computed at the point a_pt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_w</td><td>Vector of weights associated with locations indicated in the a_nPts vector. </td></tr>
    <tr><td class="paramname">a_nPts</td><td>Vector of indices into the m_pts vector for the nearest points to a_pt. </td></tr>
    <tr><td class="paramname">a_val</td><td>Interpolated value calculated in this method. </td></tr>
    <tr><td class="paramname">a_ptIdx</td><td>Index associated with a_pt that is used to later process interpolation weights. </td></tr>
    <tr><td class="paramname">a_pt</td><td>The location of the interpolation point. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_interp_idw_8cpp_source.html#l00590">590</a> of file <a class="el" href="_interp_idw_8cpp_source.html">InterpIdw.cpp</a>.</p>

<p>References <a class="el" href="_interp_idw_8cpp_source.html#l00162">m_saveWeights</a>, and <a class="el" href="_interp_idw_8cpp_source.html#l00672">ScalarFromNodalFunc()</a>.</p>

<p>Referenced by <a class="el" href="_interp_idw_8cpp_source.html#l00388">InterpToPt()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a29d8491cf7291c3aeaf0556a1d25bd06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xms::InterpIdwImpl::m_modifiedShepardWeights</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>flag for calculating weights using a the modified shepard's approach </p>

<p>Definition at line <a class="el" href="_interp_idw_8cpp_source.html#l00149">149</a> of file <a class="el" href="_interp_idw_8cpp_source.html">InterpIdw.cpp</a>.</p>

<p>Referenced by <a class="el" href="_interp_idw_8cpp_source.html#l00655">CreateNodalFunctionPtr()</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00493">InterpWeights()</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00614">SetWeightCalcMethod()</a>, and <a class="el" href="_interp_idw_8cpp_source.html#l00527">ToString()</a>.</p>

</div>
</div>
<a class="anchor" id="a3b5231a2f3ae69e877a135e1c1631561"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xms::InterpIdwImpl::m_nNearestPts</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>number of nearest points to use in the interpolation </p>

<p>Definition at line <a class="el" href="_interp_idw_8cpp_source.html#l00151">151</a> of file <a class="el" href="_interp_idw_8cpp_source.html">InterpIdw.cpp</a>.</p>

<p>Referenced by <a class="el" href="_interp_idw_8cpp_source.html#l00493">InterpWeights()</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00365">SetSearchOpts()</a>, and <a class="el" href="_interp_idw_8cpp_source.html#l00527">ToString()</a>.</p>

</div>
</div>
<a class="anchor" id="a725548983086139fc68612438afe1b4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double xms::InterpIdwImpl::m_power</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The exponent to be used with the inverse of the distance. By default this is 2 so we use 1/d^2. The exponent can be changed so that the calculation is 1/d or 1/d^3... </p>

<p>Definition at line <a class="el" href="_interp_idw_8cpp_source.html#l00155">155</a> of file <a class="el" href="_interp_idw_8cpp_source.html">InterpIdw.cpp</a>.</p>

<p>Referenced by <a class="el" href="_interp_idw_8cpp_source.html#l00655">CreateNodalFunctionPtr()</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00493">InterpWeights()</a>, <a class="el" href="_interp_idw_8cpp_source.html#l00341">SetPower()</a>, and <a class="el" href="_interp_idw_8cpp_source.html#l00527">ToString()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/travis/build/Aquaveo/xmsinterp/xmsinterp/interpolate/<a class="el" href="_interp_idw_8cpp_source.html">InterpIdw.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>xms</b></li><li class="navelem"><a class="el" href="classxms_1_1_interp_idw_impl.html">InterpIdwImpl</a></li>
    <li class="footer">Generated on Tue May 15 2018 18:37:35 for xmsinterp by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
